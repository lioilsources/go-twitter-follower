// Package follower provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package gen

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	BearerTokenScopes     = "BearerToken.Scopes"
	OAuth2UserTokenScopes = "OAuth2UserToken.Scopes"
	UserTokenScopes       = "UserToken.Scopes"
)

// Defines values for GeoType.
const (
	Feature GeoType = "Feature"
)

// Defines values for PlaceType.
const (
	Admin        PlaceType = "admin"
	City         PlaceType = "city"
	Country      PlaceType = "country"
	Neighborhood PlaceType = "neighborhood"
	Poi          PlaceType = "poi"
	Unknown      PlaceType = "unknown"
)

// Defines values for PointType.
const (
	PointTypePoint PointType = "Point"
)

// Defines values for PollVotingStatus.
const (
	Closed PollVotingStatus = "closed"
	Open   PollVotingStatus = "open"
)

// Defines values for ReplySettings.
const (
	Everyone       ReplySettings = "everyone"
	Following      ReplySettings = "following"
	MentionedUsers ReplySettings = "mentionedUsers"
	Other          ReplySettings = "other"
)

// Defines values for TweetReferencedTweetsType.
const (
	Quoted    TweetReferencedTweetsType = "quoted"
	RepliedTo TweetReferencedTweetsType = "replied_to"
	Retweeted TweetReferencedTweetsType = "retweeted"
)

// Defines values for TweetWithheldScope.
const (
	TweetWithheldScopeTweet TweetWithheldScope = "tweet"
	TweetWithheldScopeUser  TweetWithheldScope = "user"
)

// Defines values for UserWithheldScope.
const (
	UserWithheldScopeUser UserWithheldScope = "user"
)

// Defines values for FindUserByUsernameParamsUserFields.
const (
	FindUserByUsernameParamsUserFieldsCreatedAt       FindUserByUsernameParamsUserFields = "created_at"
	FindUserByUsernameParamsUserFieldsDescription     FindUserByUsernameParamsUserFields = "description"
	FindUserByUsernameParamsUserFieldsEntities        FindUserByUsernameParamsUserFields = "entities"
	FindUserByUsernameParamsUserFieldsId              FindUserByUsernameParamsUserFields = "id"
	FindUserByUsernameParamsUserFieldsLocation        FindUserByUsernameParamsUserFields = "location"
	FindUserByUsernameParamsUserFieldsName            FindUserByUsernameParamsUserFields = "name"
	FindUserByUsernameParamsUserFieldsPinnedTweetId   FindUserByUsernameParamsUserFields = "pinned_tweet_id"
	FindUserByUsernameParamsUserFieldsProfileImageUrl FindUserByUsernameParamsUserFields = "profile_image_url"
	FindUserByUsernameParamsUserFieldsProtected       FindUserByUsernameParamsUserFields = "protected"
	FindUserByUsernameParamsUserFieldsPublicMetrics   FindUserByUsernameParamsUserFields = "public_metrics"
	FindUserByUsernameParamsUserFieldsUrl             FindUserByUsernameParamsUserFields = "url"
	FindUserByUsernameParamsUserFieldsUsername        FindUserByUsernameParamsUserFields = "username"
	FindUserByUsernameParamsUserFieldsVerified        FindUserByUsernameParamsUserFields = "verified"
	FindUserByUsernameParamsUserFieldsVerifiedType    FindUserByUsernameParamsUserFields = "verified_type"
	FindUserByUsernameParamsUserFieldsWithheld        FindUserByUsernameParamsUserFields = "withheld"
)

// Defines values for FindUserByUsernameParamsExpansions.
const (
	FindUserByUsernameParamsExpansionsPinnedTweetId FindUserByUsernameParamsExpansions = "pinned_tweet_id"
)

// Defines values for FindUserByUsernameParamsTweetFields.
const (
	FindUserByUsernameParamsTweetFieldsAttachments         FindUserByUsernameParamsTweetFields = "attachments"
	FindUserByUsernameParamsTweetFieldsAuthorId            FindUserByUsernameParamsTweetFields = "author_id"
	FindUserByUsernameParamsTweetFieldsContextAnnotations  FindUserByUsernameParamsTweetFields = "context_annotations"
	FindUserByUsernameParamsTweetFieldsConversationId      FindUserByUsernameParamsTweetFields = "conversation_id"
	FindUserByUsernameParamsTweetFieldsCreatedAt           FindUserByUsernameParamsTweetFields = "created_at"
	FindUserByUsernameParamsTweetFieldsEditControls        FindUserByUsernameParamsTweetFields = "edit_controls"
	FindUserByUsernameParamsTweetFieldsEditHistoryTweetIds FindUserByUsernameParamsTweetFields = "edit_history_tweet_ids"
	FindUserByUsernameParamsTweetFieldsEntities            FindUserByUsernameParamsTweetFields = "entities"
	FindUserByUsernameParamsTweetFieldsGeo                 FindUserByUsernameParamsTweetFields = "geo"
	FindUserByUsernameParamsTweetFieldsId                  FindUserByUsernameParamsTweetFields = "id"
	FindUserByUsernameParamsTweetFieldsInReplyToUserId     FindUserByUsernameParamsTweetFields = "in_reply_to_user_id"
	FindUserByUsernameParamsTweetFieldsLang                FindUserByUsernameParamsTweetFields = "lang"
	FindUserByUsernameParamsTweetFieldsNonPublicMetrics    FindUserByUsernameParamsTweetFields = "non_public_metrics"
	FindUserByUsernameParamsTweetFieldsOrganicMetrics      FindUserByUsernameParamsTweetFields = "organic_metrics"
	FindUserByUsernameParamsTweetFieldsPossiblySensitive   FindUserByUsernameParamsTweetFields = "possibly_sensitive"
	FindUserByUsernameParamsTweetFieldsPromotedMetrics     FindUserByUsernameParamsTweetFields = "promoted_metrics"
	FindUserByUsernameParamsTweetFieldsPublicMetrics       FindUserByUsernameParamsTweetFields = "public_metrics"
	FindUserByUsernameParamsTweetFieldsReferencedTweets    FindUserByUsernameParamsTweetFields = "referenced_tweets"
	FindUserByUsernameParamsTweetFieldsReplySettings       FindUserByUsernameParamsTweetFields = "reply_settings"
	FindUserByUsernameParamsTweetFieldsSource              FindUserByUsernameParamsTweetFields = "source"
	FindUserByUsernameParamsTweetFieldsText                FindUserByUsernameParamsTweetFields = "text"
	FindUserByUsernameParamsTweetFieldsWithheld            FindUserByUsernameParamsTweetFields = "withheld"
)

// CashtagEntity defines model for CashtagEntity.
type CashtagEntity struct {
	// End Index (zero-based) at which position this entity ends.  The index is exclusive.
	End int `json:"end"`

	// Start Index (zero-based) at which position this entity starts.  The index is inclusive.
	Start int    `json:"start"`
	Tag   string `json:"tag"`
}

// CashtagFields Represent the portion of text recognized as a Cashtag, and its start and end position within the text.
type CashtagFields struct {
	Tag string `json:"tag"`
}

// ContextAnnotation Annotation inferred from the Tweet text.
type ContextAnnotation struct {
	// Domain Represents the data for the context annotation domain.
	Domain ContextAnnotationDomainFields `json:"domain"`

	// Entity Represents the data for the context annotation entity.
	Entity ContextAnnotationEntityFields `json:"entity"`
}

// ContextAnnotationDomainFields Represents the data for the context annotation domain.
type ContextAnnotationDomainFields struct {
	// Description Description of the context annotation domain.
	Description *string `json:"description,omitempty"`

	// Id The unique id for a context annotation domain.
	Id string `json:"id"`

	// Name Name of the context annotation domain.
	Name *string `json:"name,omitempty"`
}

// ContextAnnotationEntityFields Represents the data for the context annotation entity.
type ContextAnnotationEntityFields struct {
	// Description Description of the context annotation entity.
	Description *string `json:"description,omitempty"`

	// Id The unique id for a context annotation entity.
	Id string `json:"id"`

	// Name Name of the context annotation entity.
	Name *string `json:"name,omitempty"`
}

// CountryCode A two-letter ISO 3166-1 alpha-2 country code.
type CountryCode = string

// EntityIndicesInclusiveExclusive Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
type EntityIndicesInclusiveExclusive struct {
	// End Index (zero-based) at which position this entity ends.  The index is exclusive.
	End int `json:"end"`

	// Start Index (zero-based) at which position this entity starts.  The index is inclusive.
	Start int `json:"start"`
}

// EntityIndicesInclusiveInclusive Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is inclusive.
type EntityIndicesInclusiveInclusive struct {
	// End Index (zero-based) at which position this entity ends.  The index is inclusive.
	End int `json:"end"`

	// Start Index (zero-based) at which position this entity starts.  The index is inclusive.
	Start int `json:"start"`
}

// Error defines model for Error.
type Error struct {
	Code    int32  `json:"code"`
	Message string `json:"message"`
}

// Expansions defines model for Expansions.
type Expansions struct {
	Media  *[]Media `json:"media,omitempty"`
	Places *[]Place `json:"places,omitempty"`
	Polls  *[]Poll  `json:"polls,omitempty"`
	Topics *[]Topic `json:"topics,omitempty"`
	Tweets *[]Tweet `json:"tweets,omitempty"`
	Users  *[]User  `json:"users,omitempty"`
}

// FullTextEntities defines model for FullTextEntities.
type FullTextEntities struct {
	Annotations *[]struct {
		// End Index (zero-based) at which position this entity ends.  The index is inclusive.
		End int `json:"end"`

		// NormalizedText Text used to determine annotation.
		NormalizedText *string `json:"normalized_text,omitempty"`

		// Probability Confidence factor for annotation type.
		Probability *float64 `json:"probability,omitempty"`

		// Start Index (zero-based) at which position this entity starts.  The index is inclusive.
		Start int `json:"start"`

		// Type Annotation type.
		Type *string `json:"type,omitempty"`
	} `json:"annotations,omitempty"`
	Cashtags *[]CashtagEntity `json:"cashtags,omitempty"`
	Hashtags *[]HashtagEntity `json:"hashtags,omitempty"`
	Mentions *[]MentionEntity `json:"mentions,omitempty"`
	Urls     *[]UrlEntity     `json:"urls,omitempty"`
}

// Geo defines model for Geo.
type Geo struct {
	Bbox []float64 `json:"bbox"`

	// Geometry A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
	Geometry   *Point                 `json:"geometry,omitempty"`
	Properties map[string]interface{} `json:"properties"`
	Type       GeoType                `json:"type"`
}

// GeoType defines model for Geo.Type.
type GeoType string

// Get2UsersByUsernameUsernameResponse defines model for Get2UsersByUsernameUsernameResponse.
type Get2UsersByUsernameUsernameResponse struct {
	// Data The Twitter User object.
	Data     *User       `json:"data,omitempty"`
	Errors   *[]Problem  `json:"errors,omitempty"`
	Includes *Expansions `json:"includes,omitempty"`
}

// HashtagEntity defines model for HashtagEntity.
type HashtagEntity struct {
	// End Index (zero-based) at which position this entity ends.  The index is exclusive.
	End int `json:"end"`

	// Start Index (zero-based) at which position this entity starts.  The index is inclusive.
	Start int `json:"start"`

	// Tag The text of the Hashtag.
	Tag string `json:"tag"`
}

// HashtagFields Represent the portion of text recognized as a Hashtag, and its start and end position within the text.
type HashtagFields struct {
	// Tag The text of the Hashtag.
	Tag string `json:"tag"`
}

// HttpStatusCode HTTP Status Code.
type HttpStatusCode = int

// Media defines model for Media.
type Media struct {
	// Height The height of the media in pixels.
	Height *MediaHeight `json:"height,omitempty"`

	// MediaKey The Media Key identifier for this attachment.
	MediaKey *MediaKey `json:"media_key,omitempty"`
	Type     string    `json:"type"`

	// Width The width of the media in pixels.
	Width *MediaWidth `json:"width,omitempty"`
}

// MediaHeight The height of the media in pixels.
type MediaHeight = int

// MediaKey The Media Key identifier for this attachment.
type MediaKey = string

// MediaWidth The width of the media in pixels.
type MediaWidth = int

// MentionEntity defines model for MentionEntity.
type MentionEntity struct {
	// End Index (zero-based) at which position this entity ends.  The index is exclusive.
	End int `json:"end"`

	// Id Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
	Id *UserId `json:"id,omitempty"`

	// Start Index (zero-based) at which position this entity starts.  The index is inclusive.
	Start int `json:"start"`

	// Username The Twitter handle (screen name) of this user.
	Username UserName `json:"username"`
}

// MentionFields Represent the portion of text recognized as a User mention, and its start and end position within the text.
type MentionFields struct {
	// Id Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
	Id *UserId `json:"id,omitempty"`

	// Username The Twitter handle (screen name) of this user.
	Username UserName `json:"username"`
}

// Place defines model for Place.
type Place struct {
	ContainedWithin *[]PlaceId `json:"contained_within,omitempty"`

	// Country The full name of the county in which this place exists.
	Country *string `json:"country,omitempty"`

	// CountryCode A two-letter ISO 3166-1 alpha-2 country code.
	CountryCode *CountryCode `json:"country_code,omitempty"`

	// FullName The full name of this place.
	FullName string `json:"full_name"`
	Geo      *Geo   `json:"geo,omitempty"`

	// Id The identifier for this place.
	Id PlaceId `json:"id"`

	// Name The human readable name of this place.
	Name      *string    `json:"name,omitempty"`
	PlaceType *PlaceType `json:"place_type,omitempty"`
}

// PlaceId The identifier for this place.
type PlaceId = string

// PlaceType defines model for PlaceType.
type PlaceType string

// Point A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
type Point struct {
	// Coordinates A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`.
	Coordinates Position  `json:"coordinates"`
	Type        PointType `json:"type"`
}

// PointType defines model for Point.Type.
type PointType string

// Poll Represent a Poll attached to a Tweet.
type Poll struct {
	DurationMinutes *int32     `json:"duration_minutes,omitempty"`
	EndDatetime     *time.Time `json:"end_datetime,omitempty"`

	// Id Unique identifier of this poll.
	Id           PollId            `json:"id"`
	Options      []PollOption      `json:"options"`
	VotingStatus *PollVotingStatus `json:"voting_status,omitempty"`
}

// PollVotingStatus defines model for Poll.VotingStatus.
type PollVotingStatus string

// PollId Unique identifier of this poll.
type PollId = string

// PollOption Describes a choice in a Poll object.
type PollOption struct {
	// Label The text of a poll choice.
	Label PollOptionLabel `json:"label"`

	// Position Position of this choice in the poll.
	Position int `json:"position"`

	// Votes Number of users who voted for this choice.
	Votes int `json:"votes"`
}

// PollOptionLabel The text of a poll choice.
type PollOptionLabel = string

// Position A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`.
type Position = []float32

// Problem An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
type Problem struct {
	Detail *string `json:"detail,omitempty"`
	Status *int    `json:"status,omitempty"`
	Title  string  `json:"title"`
	Type   string  `json:"type"`
}

// ReplySettings Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following.
type ReplySettings string

// Topic The topic of a Space, as selected by its creator.
type Topic struct {
	// Description The description of the given topic.
	Description *string `json:"description,omitempty"`

	// Id Unique identifier of this Topic.
	Id TopicId `json:"id"`

	// Name The name of the given topic.
	Name string `json:"name"`
}

// TopicId Unique identifier of this Topic.
type TopicId = string

// Tweet defines model for Tweet.
type Tweet struct {
	// Attachments Specifies the type of attachments (if any) present in this Tweet.
	Attachments *struct {
		// MediaKeys A list of Media Keys for each one of the media attachments (if media are attached).
		MediaKeys *[]MediaKey `json:"media_keys,omitempty"`

		// PollIds A list of poll IDs (if polls are attached).
		PollIds *[]PollId `json:"poll_ids,omitempty"`
	} `json:"attachments,omitempty"`

	// AuthorId Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
	AuthorId           *UserId              `json:"author_id,omitempty"`
	ContextAnnotations *[]ContextAnnotation `json:"context_annotations,omitempty"`

	// ConversationId Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
	ConversationId *TweetId `json:"conversation_id,omitempty"`

	// CreatedAt Creation time of the Tweet.
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	EditControls *struct {
		// EditableUntil Time when Tweet is no longer editable.
		EditableUntil time.Time `json:"editable_until"`

		// EditsRemaining Number of times this Tweet can be edited.
		EditsRemaining int `json:"edits_remaining"`

		// IsEditEligible Indicates if this Tweet is eligible to be edited.
		IsEditEligible bool `json:"is_edit_eligible"`
	} `json:"edit_controls,omitempty"`

	// EditHistoryTweetIds A list of Tweet Ids in this Tweet chain.
	EditHistoryTweetIds []TweetId         `json:"edit_history_tweet_ids"`
	Entities            *FullTextEntities `json:"entities,omitempty"`

	// Geo The location tagged on the Tweet, if the user provided one.
	Geo *struct {
		// Coordinates A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
		Coordinates *Point `json:"coordinates,omitempty"`

		// PlaceId The identifier for this place.
		PlaceId *PlaceId `json:"place_id,omitempty"`
	} `json:"geo,omitempty"`

	// Id Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
	Id TweetId `json:"id"`

	// InReplyToUserId Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
	InReplyToUserId *UserId `json:"in_reply_to_user_id,omitempty"`

	// Lang Language of the Tweet, if detected by Twitter. Returned as a BCP47 language tag.
	Lang *string `json:"lang,omitempty"`

	// NonPublicMetrics Nonpublic engagement metrics for the Tweet at the time of the request.
	NonPublicMetrics *struct {
		// ImpressionCount Number of times this Tweet has been viewed.
		ImpressionCount *int32 `json:"impression_count,omitempty"`
	} `json:"non_public_metrics,omitempty"`

	// OrganicMetrics Organic nonpublic engagement metrics for the Tweet at the time of the request.
	OrganicMetrics *struct {
		// ImpressionCount Number of times this Tweet has been viewed.
		ImpressionCount int `json:"impression_count"`

		// LikeCount Number of times this Tweet has been liked.
		LikeCount int `json:"like_count"`

		// ReplyCount Number of times this Tweet has been replied to.
		ReplyCount int `json:"reply_count"`

		// RetweetCount Number of times this Tweet has been Retweeted.
		RetweetCount int `json:"retweet_count"`
	} `json:"organic_metrics,omitempty"`

	// PossiblySensitive Indicates if this Tweet contains URLs marked as sensitive, for example content suitable for mature audiences.
	PossiblySensitive *bool `json:"possibly_sensitive,omitempty"`

	// PromotedMetrics Promoted nonpublic engagement metrics for the Tweet at the time of the request.
	PromotedMetrics *struct {
		// ImpressionCount Number of times this Tweet has been viewed.
		ImpressionCount *int32 `json:"impression_count,omitempty"`

		// LikeCount Number of times this Tweet has been liked.
		LikeCount *int32 `json:"like_count,omitempty"`

		// ReplyCount Number of times this Tweet has been replied to.
		ReplyCount *int32 `json:"reply_count,omitempty"`

		// RetweetCount Number of times this Tweet has been Retweeted.
		RetweetCount *int32 `json:"retweet_count,omitempty"`
	} `json:"promoted_metrics,omitempty"`

	// PublicMetrics Engagement metrics for the Tweet at the time of the request.
	PublicMetrics *struct {
		// ImpressionCount Number of times this Tweet has been viewed.
		ImpressionCount int32 `json:"impression_count"`

		// LikeCount Number of times this Tweet has been liked.
		LikeCount int `json:"like_count"`

		// QuoteCount Number of times this Tweet has been quoted.
		QuoteCount *int `json:"quote_count,omitempty"`

		// ReplyCount Number of times this Tweet has been replied to.
		ReplyCount int `json:"reply_count"`

		// RetweetCount Number of times this Tweet has been Retweeted.
		RetweetCount int `json:"retweet_count"`
	} `json:"public_metrics,omitempty"`

	// ReferencedTweets A list of Tweets this Tweet refers to. For example, if the parent Tweet is a Retweet, a Quoted Tweet or a Reply, it will include the related Tweet referenced to by its parent.
	ReferencedTweets *[]struct {
		// Id Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
		Id   TweetId                   `json:"id"`
		Type TweetReferencedTweetsType `json:"type"`
	} `json:"referenced_tweets,omitempty"`

	// ReplySettings Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following.
	ReplySettings *ReplySettings `json:"reply_settings,omitempty"`

	// Source This is deprecated.
	Source *string `json:"source,omitempty"`

	// Text The content of the Tweet.
	Text TweetText `json:"text"`

	// Withheld Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
	Withheld *TweetWithheld `json:"withheld,omitempty"`
}

// TweetReferencedTweetsType defines model for Tweet.ReferencedTweets.Type.
type TweetReferencedTweetsType string

// TweetId Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
type TweetId = string

// TweetText The content of the Tweet.
type TweetText = string

// TweetWithheld Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
type TweetWithheld struct {
	// Copyright Indicates if the content is being withheld for on the basis of copyright infringement.
	Copyright bool `json:"copyright"`

	// CountryCodes Provides a list of countries where this content is not available.
	CountryCodes []CountryCode `json:"country_codes"`

	// Scope Indicates whether the content being withheld is the `tweet` or a `user`.
	Scope *TweetWithheldScope `json:"scope,omitempty"`
}

// TweetWithheldScope Indicates whether the content being withheld is the `tweet` or a `user`.
type TweetWithheldScope string

// Url A validly formatted URL.
type Url = string

// UrlEntity defines model for UrlEntity.
type UrlEntity struct {
	// Description Description of the URL landing page.
	Description *string `json:"description,omitempty"`

	// DisplayUrl The URL as displayed in the Twitter client.
	DisplayUrl *string `json:"display_url,omitempty"`

	// End Index (zero-based) at which position this entity ends.  The index is exclusive.
	End int `json:"end"`

	// ExpandedUrl A validly formatted URL.
	ExpandedUrl *Url        `json:"expanded_url,omitempty"`
	Images      *[]UrlImage `json:"images,omitempty"`

	// MediaKey The Media Key identifier for this attachment.
	MediaKey *MediaKey `json:"media_key,omitempty"`

	// Start Index (zero-based) at which position this entity starts.  The index is inclusive.
	Start int `json:"start"`

	// Status HTTP Status Code.
	Status *HttpStatusCode `json:"status,omitempty"`

	// Title Title of the page the URL points to.
	Title *string `json:"title,omitempty"`

	// UnwoundUrl Fully resolved url.
	UnwoundUrl *string `json:"unwound_url,omitempty"`

	// Url A validly formatted URL.
	Url Url `json:"url"`
}

// UrlFields Represent the portion of text recognized as a URL.
type UrlFields struct {
	// Description Description of the URL landing page.
	Description *string `json:"description,omitempty"`

	// DisplayUrl The URL as displayed in the Twitter client.
	DisplayUrl *string `json:"display_url,omitempty"`

	// ExpandedUrl A validly formatted URL.
	ExpandedUrl *Url        `json:"expanded_url,omitempty"`
	Images      *[]UrlImage `json:"images,omitempty"`

	// MediaKey The Media Key identifier for this attachment.
	MediaKey *MediaKey `json:"media_key,omitempty"`

	// Status HTTP Status Code.
	Status *HttpStatusCode `json:"status,omitempty"`

	// Title Title of the page the URL points to.
	Title *string `json:"title,omitempty"`

	// UnwoundUrl Fully resolved url.
	UnwoundUrl *string `json:"unwound_url,omitempty"`

	// Url A validly formatted URL.
	Url Url `json:"url"`
}

// UrlImage Represent the information for the URL image.
type UrlImage struct {
	// Height The height of the media in pixels.
	Height *MediaHeight `json:"height,omitempty"`

	// Url A validly formatted URL.
	Url *Url `json:"url,omitempty"`

	// Width The width of the media in pixels.
	Width *MediaWidth `json:"width,omitempty"`
}

// User The Twitter User object.
type User struct {
	// CreatedAt Creation time of this User.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Description The text of this User's profile description (also known as bio), if the User provided one.
	Description *string `json:"description,omitempty"`

	// Entities A list of metadata found in the User's profile description.
	Entities *struct {
		Description *FullTextEntities `json:"description,omitempty"`

		// Url Expanded details for the URL specified in the User's profile, with start and end indices.
		Url *struct {
			Urls *[]UrlEntity `json:"urls,omitempty"`
		} `json:"url,omitempty"`
	} `json:"entities,omitempty"`

	// Id Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
	Id UserId `json:"id"`

	// Location The location specified in the User's profile, if the User provided one. As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries.
	Location *string `json:"location,omitempty"`

	// Name The friendly name of this User, as shown on their profile.
	Name string `json:"name"`

	// PinnedTweetId Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
	PinnedTweetId *TweetId `json:"pinned_tweet_id,omitempty"`

	// ProfileImageUrl The URL to the profile image for this User.
	ProfileImageUrl *string `json:"profile_image_url,omitempty"`

	// Protected Indicates if this User has chosen to protect their Tweets (in other words, if this User's Tweets are private).
	Protected *bool `json:"protected,omitempty"`

	// PublicMetrics A list of metrics for this User.
	PublicMetrics *struct {
		// FollowersCount Number of Users who are following this User.
		FollowersCount int `json:"followers_count"`

		// FollowingCount Number of Users this User is following.
		FollowingCount int `json:"following_count"`

		// ListedCount The number of lists that include this User.
		ListedCount int `json:"listed_count"`

		// TweetCount The number of Tweets (including Retweets) posted by this User.
		TweetCount int `json:"tweet_count"`
	} `json:"public_metrics,omitempty"`

	// Url The URL specified in the User's profile.
	Url *string `json:"url,omitempty"`

	// Username The Twitter handle (screen name) of this user.
	Username UserName `json:"username"`

	// Verified Indicate if this User is a verified Twitter User.
	Verified *bool `json:"verified,omitempty"`

	// VerifiedType The Twitter Blue verified type of the user, eg: blue, government, business or none.
	VerifiedType *string `json:"verified_type,omitempty"`

	// Withheld Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
	Withheld *UserWithheld `json:"withheld,omitempty"`
}

// UserId Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
type UserId = string

// UserName The Twitter handle (screen name) of this user.
type UserName = string

// UserWithheld Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
type UserWithheld struct {
	// CountryCodes Provides a list of countries where this content is not available.
	CountryCodes []CountryCode `json:"country_codes"`

	// Scope Indicates that the content being withheld is a `user`.
	Scope *UserWithheldScope `json:"scope,omitempty"`
}

// UserWithheldScope Indicates that the content being withheld is a `user`.
type UserWithheldScope string

// TweetFieldsParameter The fields available for a Tweet object.
type TweetFieldsParameter = []string

// UserExpansionsParameter The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
type UserExpansionsParameter = []string

// UserFieldsParameter The fields available for a User object.
type UserFieldsParameter = []string

// FindUserByUsernameParams defines parameters for FindUserByUsername.
type FindUserByUsernameParams struct {
	// UserFields A comma separated list of User fields to display.
	UserFields *UserFieldsParameter `form:"user.fields,omitempty" json:"user.fields,omitempty"`

	// Expansions A comma separated list of fields to expand.
	Expansions *UserExpansionsParameter `form:"expansions,omitempty" json:"expansions,omitempty"`

	// TweetFields A comma separated list of Tweet fields to display.
	TweetFields *TweetFieldsParameter `form:"tweet.fields,omitempty" json:"tweet.fields,omitempty"`
}

// FindUserByUsernameParamsUserFields defines parameters for FindUserByUsername.
type FindUserByUsernameParamsUserFields string

// FindUserByUsernameParamsExpansions defines parameters for FindUserByUsername.
type FindUserByUsernameParamsExpansions string

// FindUserByUsernameParamsTweetFields defines parameters for FindUserByUsername.
type FindUserByUsernameParamsTweetFields string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// FindUserByUsername request
	FindUserByUsername(ctx context.Context, username string, params *FindUserByUsernameParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) FindUserByUsername(ctx context.Context, username string, params *FindUserByUsernameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindUserByUsernameRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewFindUserByUsernameRequest generates requests for FindUserByUsername
func NewFindUserByUsernameRequest(server string, username string, params *FindUserByUsernameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/2/users/by/username/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UserFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user.fields", runtime.ParamLocationQuery, *params.UserFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expansions != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "expansions", runtime.ParamLocationQuery, *params.Expansions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TweetFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tweet.fields", runtime.ParamLocationQuery, *params.TweetFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// FindUserByUsername request
	FindUserByUsernameWithResponse(ctx context.Context, username string, params *FindUserByUsernameParams, reqEditors ...RequestEditorFn) (*FindUserByUsernameResponse, error)
}

type FindUserByUsernameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Get2UsersByUsernameUsernameResponse
	//JSONDefault  *Error
	JSONDefault  *Problem
}

// Status returns HTTPResponse.Status
func (r FindUserByUsernameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindUserByUsernameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// FindUserByUsernameWithResponse request returning *FindUserByUsernameResponse
func (c *ClientWithResponses) FindUserByUsernameWithResponse(ctx context.Context, username string, params *FindUserByUsernameParams, reqEditors ...RequestEditorFn) (*FindUserByUsernameResponse, error) {
	rsp, err := c.FindUserByUsername(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindUserByUsernameResponse(rsp)
}

// ParseFindUserByUsernameResponse parses an HTTP response from a FindUserByUsernameWithResponse call
func ParseFindUserByUsernameResponse(rsp *http.Response) (*FindUserByUsernameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindUserByUsernameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Get2UsersByUsernameUsernameResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
